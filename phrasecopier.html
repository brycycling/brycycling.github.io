<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phrase Copier</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the color input to make it look like a swatch */
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 9999px; /* Tailwind's rounded-full */
        }
        input[type="color"]::-moz-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 9999px;
        }
        /* Hide the native color picker text label, keep only the swatch */
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 32px; /* Equivalent to Tailwind w-8 */
            height: 32px; /* Equivalent to Tailwind h-8 */
            border-radius: 9999px;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            overflow: hidden; /* Hide any default browser styling */
        }

        /* Ensure textarea expands correctly */
        textarea {
            overflow: hidden; /* Hide scrollbar */
        }
    </style>
</head>
<body class="font-inter">
    <div id="root"></div>

    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel Standalone for JSX compilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase CDNs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, addDoc, updateDoc, doc, deleteDoc, query, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // This ensures the global variables are accessible to the React component
        window.firebaseDependencies = {
            initializeApp,
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            onAuthStateChanged,
            getFirestore,
            collection,
            onSnapshot,
            addDoc,
            updateDoc,
            doc,
            deleteDoc,
            query,
            writeBatch // Added writeBatch for drag and drop updates
        };

        // Firebase configuration and authentication logic
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const app = initializeApp(firebaseConfig);
        const firestore = getFirestore(app);
        const authentication = getAuth(app);

        // Store these for use in the React component
        window.dbInstance = firestore;
        window.authInstance = authentication;

        // Sign in anonymously if no user is authenticated on initial load
        onAuthStateChanged(authentication, async (user) => {
            if (!user) {
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if (initialAuthToken) {
                    await signInWithCustomToken(authentication, initialAuthToken)
                        .catch(error => console.error("Error signing in with custom token:", error));
                } else {
                    await signInAnonymously(authentication)
                        .catch(error => console.error("Error signing in anonymously:", error));
                }
            }
        });
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { createRoot } = ReactDOM; // Use createRoot for React 18

        function App() {
            const [phrases, setPhrases] = useState([]);
            const [newPhraseText, setNewPhraseText] = useState('');
            const [db, setDb] = useState(null);
            const [auth, setAuth] = useState(null);
            const [userId, setUserId] = useState(null);
            const [isAuthReady, setIsAuthReady] = useState(false);
            const [message, setMessage] = useState('');
            const draggedItem = useRef(null);
            const draggedOverItem = useRef(null);
            const [editingPhraseId, setEditingPhraseId] = useState(null);
            const [currentEditText, setCurrentEditText] = useState('');
            const textareaRef = useRef(null);

            // Initialize Firebase instances and check auth status
            useEffect(() => {
                // Ensure Firebase dependencies are loaded before trying to use them
                if (window.firebaseDependencies && window.dbInstance && window.authInstance) {
                    setDb(window.dbInstance);
                    setAuth(window.authInstance);

                    // Listen to auth state changes to set userId and isAuthReady
                    const unsubscribeAuth = window.firebaseDependencies.onAuthStateChanged(window.authInstance, (user) => {
                        if (user) {
                            setUserId(user.uid);
                            setIsAuthReady(true);
                        } else {
                            // This case should be handled by the initial script if token is missing
                            // but adding a fallback for robustness.
                            console.log("Auth state changed, user is null. Initializing anonymous sign-in if not already.");
                        }
                    });
                    return () => unsubscribeAuth();
                }
            }, []);

            // Effect to adjust textarea height when editing text changes
            useEffect(() => {
                if (textareaRef.current) {
                    textareaRef.current.style.height = 'auto';
                    textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
                }
            }, [currentEditText, editingPhraseId]);

            // Listen for real-time updates from Firestore
            useEffect(() => {
                if (!db || !userId || !isAuthReady) return;

                const { collection, onSnapshot, query } = window.firebaseDependencies;
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const phrasesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/phrases`);

                // Create a query. Note: orderBy is commented out as requested previously to avoid index issues.
                const q = query(phrasesCollectionRef);

                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const fetchedPhrases = snapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
                    fetchedPhrases.sort((a, b) => (a.order || 0) - (b.order || 0)); // Ensure 'order' exists and sort locally
                    setPhrases(fetchedPhrases);
                }, (error) => {
                    console.error("Error fetching phrases:", error);
                    setMessage("Failed to load phrases.");
                });

                return () => unsubscribe();
            }, [db, userId, isAuthReady]); // Re-run if db, userId, or auth status changes

            const addPhrase = async () => {
                if (newPhraseText.trim() === '' || !db || !userId) {
                    setMessage("Phrase cannot be empty.");
                    return;
                }

                try {
                    const { addDoc, collection } = window.firebaseDependencies;
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const phrasesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/phrases`);
                    const newOrder = phrases.length > 0 ? Math.max(...phrases.map(p => p.order || 0)) + 1 : 0;

                    await addDoc(phrasesCollectionRef, {
                        text: newPhraseText,
                        order: newOrder,
                        backgroundColor: '#ffffff'
                    });
                    setNewPhraseText('');
                    setMessage("Phrase added!");
                } catch (e) {
                    console.error("Error adding document: ", e);
                    setMessage("Failed to add phrase.");
                }
            };

            const copyToClipboard = (text) => {
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    setMessage('Copied to clipboard!');
                    setTimeout(() => setMessage(''), 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    setMessage('Failed to copy to clipboard.');
                }
            };

            const handleDragStart = (e, index) => {
                draggedItem.current = index;
            };

            const handleDragEnter = (e, index) => {
                draggedOverItem.current = index;
            };

            const handleDrop = async (e) => {
                const newPhrases = [...phrases];
                const draggedContent = newPhrases[draggedItem.current];
                newPhrases.splice(draggedItem.current, 1);
                newPhrases.splice(draggedOverItem.current, 0, draggedContent);

                if (db && userId) {
                    const { writeBatch, doc, collection } = window.firebaseDependencies;
                    const batch = writeBatch(db); // Use Firestore batch for atomic updates
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    
                    newPhrases.forEach((phrase, index) => {
                        // Create a reference to the specific document using doc(db, collectionPath, docId)
                        const phraseRef = doc(collection(db, `artifacts/${appId}/users/${userId}/phrases`), phrase.id);
                        batch.update(phraseRef, { order: index });
                    });

                    try {
                        await batch.commit();
                        setMessage("Phrases reordered!");
                    } catch (error) {
                        console.error("Error updating phrase order in Firestore batch:", error);
                        setMessage("Failed to reorder phrases.");
                    }
                }

                draggedItem.current = null;
                draggedOverItem.current = null;
            };

            const handleDragOver = (e) => {
                e.preventDefault();
            };

            const deletePhrase = async (id) => {
                if (!db || !userId) return;

                try {
                    const { deleteDoc, doc, collection } = window.firebaseDependencies;
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    await deleteDoc(doc(collection(db, `artifacts/${appId}/users/${userId}/phrases`), id));
                    setMessage("Phrase deleted!");
                    setEditingPhraseId(null);
                } catch (error) {
                    console.error("Error deleting phrase:", error);
                    setMessage("Failed to delete phrase.");
                }
            };

            const updatePhraseColor = async (id, newColor) => {
                if (!db || !userId) return;

                try {
                    const { updateDoc, doc, collection } = window.firebaseDependencies;
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const phraseRef = doc(collection(db, `artifacts/${appId}/users/${userId}/phrases`), id);
                    await updateDoc(phraseRef, { backgroundColor: newColor });
                    setMessage("Color updated!");
                } catch (error) {
                    console.error("Error updating phrase color:", error);
                    setMessage("Failed to update color.");
                }
            };

            const enableEdit = (phrase) => {
                setEditingPhraseId(phrase.id);
                setCurrentEditText(phrase.text);
            };

            const saveEditedPhrase = async (id) => {
                if (currentEditText.trim() === '' || !db || !userId) {
                    setMessage("Phrase cannot be empty.");
                    return;
                }

                try {
                    const { updateDoc, doc, collection } = window.firebaseDependencies;
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const phraseRef = doc(collection(db, `artifacts/${appId}/users/${userId}/phrases`), id);
                    await updateDoc(phraseRef, { text: currentEditText });
                    setEditingPhraseId(null);
                    setMessage("Phrase updated!");
                } catch (error) {
                    console.error("Error updating phrase text:", error);
                    setMessage("Failed to update phrase.");
                }
            };

            const cancelEdit = () => {
                setEditingPhraseId(null);
                setCurrentEditText('');
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-gray-200 to-blue-200 flex flex-col items-center justify-center p-4 text-gray-700">
                    <div className="w-full max-w-2xl bg-white p-6 rounded-xl shadow-lg space-y-4">
                        <h1 className="text-3xl font-bold text-center text-blue-800 mb-4">
                            Phrase Copier
                        </h1>

                        {userId && (
                            <div className="text-xs text-gray-500 text-center mb-3">
                                User ID: <span className="font-mono bg-gray-100 px-1.5 py-0.5 rounded">{userId}</span>
                            </div>
                        )}

                        {message && (
                            <div className="bg-blue-50 text-blue-700 p-2 rounded-md text-center text-sm font-medium">
                                {message}
                            </div>
                        )}

                        <div className="flex flex-col sm:flex-row gap-3 mb-5">
                            <input
                                type="text"
                                className="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-1 focus:ring-blue-400 focus:border-transparent text-base"
                                placeholder="Add a new phrase..."
                                value={newPhraseText}
                                onChange={(e) => setNewPhraseText(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') addPhrase();
                                }}
                            />
                            <button
                                onClick={addPhrase}
                                className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-5 rounded-lg shadow-sm transition duration-300 ease-in-out transform hover:scale-105 text-base"
                            >
                                Add Phrase
                            </button>
                        </div>

                        <div className="space-y-3">
                            {phrases.length === 0 ? (
                                <p className="text-center text-gray-500 text-base">No phrases yet! Add some above.</p>
                            ) : (
                                phrases.map((phrase, index) => (
                                    <div
                                        key={phrase.id}
                                        className="flex items-center p-3 rounded-lg shadow-sm border border-gray-200 cursor-grab active:cursor-grabbing"
                                        style={{ backgroundColor: phrase.backgroundColor || '#ffffff' }}
                                        draggable
                                        onDragStart={(e) => handleDragStart(e, index)}
                                        onDragEnter={(e) => handleDragEnter(e, index)}
                                        onDragEnd={handleDrop}
                                        onDragOver={handleDragOver}
                                    >
                                        <span className="text-gray-400 mr-2 text-lg">&#9776;</span>
                                        {editingPhraseId === phrase.id ? (
                                            <>
                                                <textarea
                                                    ref={textareaRef}
                                                    value={currentEditText}
                                                    onChange={(e) => setCurrentEditText(e.target.value)}
                                                    onKeyPress={(e) => {
                                                        if (e.key === 'Enter' && !e.shiftKey) {
                                                            e.preventDefault();
                                                            saveEditedPhrase(phrase.id);
                                                        }
                                                    }}
                                                    onBlur={() => saveEditedPhrase(phrase.id)}
                                                    className="flex-grow p-1 border border-blue-300 rounded-md focus:ring-1 focus:ring-blue-400 text-base resize-none overflow-hidden min-h-[38px]"
                                                    autoFocus
                                                    rows="1"
                                                />
                                                <div className="relative flex items-center ml-2">
                                                    <button
                                                        onClick={() => document.getElementById(`color-picker-${phrase.id}`).click()}
                                                        onMouseDown={(e) => e.preventDefault()}
                                                        className="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-1.5 px-3 rounded-lg shadow-sm transition duration-200 ease-in-out text-sm flex items-center justify-center"
                                                        title="Change background color"
                                                    >
                                                        Color
                                                    </button>
                                                    <input
                                                        type="color"
                                                        id={`color-picker-${phrase.id}`}
                                                        className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                                        value={phrase.backgroundColor || '#ffffff'}
                                                        onChange={(e) => updatePhraseColor(phrase.id, e.target.value)}
                                                        onMouseDown={(e) => e.preventDefault()}
                                                    />
                                                </div>

                                                <button
                                                    onClick={() => saveEditedPhrase(phrase.id)}
                                                    className="bg-blue-500 hover:bg-blue-600 text-white font-medium py-1.5 px-3 rounded-lg shadow-sm transition duration-200 ease-in-out ml-2 text-sm"
                                                >
                                                    Save
                                                </button>
                                                <button
                                                    onClick={cancelEdit}
                                                    className="bg-gray-400 hover:bg-gray-500 text-white font-medium py-1.5 px-3 rounded-lg shadow-sm transition duration-200 ease-in-out ml-1 text-sm"
                                                >
                                                    Cancel
                                                </button>
                                                <button
                                                    onClick={() => deletePhrase(phrase.id)}
                                                    className="bg-red-500 hover:bg-red-600 text-white font-medium py-1.5 px-3 rounded-lg shadow-sm transition duration-200 ease-in-out ml-1 flex items-center text-sm"
                                                >
                                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                        <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
                                                    </svg>
                                                </button>
                                            </>
                                        ) : (
                                            <>
                                                <p className="flex-grow text-gray-700 text-base whitespace-pre-wrap">{phrase.text}</p>
                                                <button
                                                    onClick={() => enableEdit(phrase)}
                                                    className="bg-blue-400 hover:bg-blue-500 text-white font-medium py-1.5 px-3 rounded-lg shadow-sm transition duration-200 ease-in-out mr-2 flex items-center text-sm"
                                                >
                                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                                        <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.38-2.827-2.828z" />
                                                    </svg>
                                                    Edit
                                                </button>
                                                <button
                                                    onClick={() => copyToClipboard(phrase.text)}
                                                    className="bg-green-500 hover:bg-green-600 text-white font-medium py-1.5 px-3 rounded-lg shadow-sm transition duration-200 ease-in-out flex items-center text-sm"
                                                >
                                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                                        <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                                                        <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" />
                                                    </svg>
                                                    Copy
                                                </button>
                                            </>
                                        )}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        // Mount the React application
        const container = document.getElementById('root');
        const root = createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
